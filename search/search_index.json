{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"librime-lua: Extending RIME with Lua scripts Features Supports extending RIME processors, segmentors, translators and filters Provides high-level programming model for translators and filters Loaded dynamically as a librime plugin Usage Create PATH_TO_RIME_USER_DATA_DIR/rime.lua : function date_translator(input, seg) if (input == \"date\") then --- Candidate(type, start, end, text, comment) yield(Candidate(\"date\", seg.start, seg._end, os.date(\"%Y\u5e74%m\u6708%d\u65e5\"), \" \u65e5\u671f\")) end end function single_char_first_filter(input) local l = {} for cand in input:iter() do if (utf8.len(cand.text) == 1) then yield(cand) else table.insert(l, cand) end end for i, cand in ipairs(l) do yield(cand) end end More sample: rime.lua Reference Lua functions in your schema: engine: ... translators: ... - lua_translator@date_translator - lua_translator@other_lua_function1 ... filters: ... - lua_filter@single_char_first_filter - lua_filter@other_lua_function2 Deploy & try Build Build dependencies librime >= 1.5.0 LuaJIT 2 / Lua 5.1 / Lua 5.2 / Lua 5.3 / Lua 5.4 Prebuilt versions Windows 1.4.0 backport master Instructions Prepare source code Move the source to the plugins directory of librime: mv librime-lua $PATH_TO_RIME_SOURCE/plugins/lua Or you can use the install-plugins.sh script to automatically fetch librime-lua: cd $PATH_TO_RIME_SOURCE bash install-plugins.sh hchunhui/librime-lua Install dependencies Install development files of Lua: # For Debian/Ubuntu: sudo apt install liblua5.3-dev # or libluajit-5.1-dev The build system will use pkg-config to search Lua. The build system also supports building Lua from source in the thirdparty directory. The thirdparty directory can be downloaded using the following commands: cd $PATH_TO_RIME_SOURCE/plugins/lua git clone https://github.com/hchunhui/librime-lua.git -b thirdparty --depth=1 thirdparty Build Follow the librime's build instructions. # On Linux, merged build make merged-plugins sudo make install For more information on RIME plugins, see here .","title":"Home"},{"location":"#librime-lua-extending-rime-with-lua-scripts","text":"","title":"librime-lua: Extending RIME with Lua scripts"},{"location":"#features","text":"Supports extending RIME processors, segmentors, translators and filters Provides high-level programming model for translators and filters Loaded dynamically as a librime plugin","title":"Features"},{"location":"#usage","text":"Create PATH_TO_RIME_USER_DATA_DIR/rime.lua : function date_translator(input, seg) if (input == \"date\") then --- Candidate(type, start, end, text, comment) yield(Candidate(\"date\", seg.start, seg._end, os.date(\"%Y\u5e74%m\u6708%d\u65e5\"), \" \u65e5\u671f\")) end end function single_char_first_filter(input) local l = {} for cand in input:iter() do if (utf8.len(cand.text) == 1) then yield(cand) else table.insert(l, cand) end end for i, cand in ipairs(l) do yield(cand) end end More sample: rime.lua Reference Lua functions in your schema: engine: ... translators: ... - lua_translator@date_translator - lua_translator@other_lua_function1 ... filters: ... - lua_filter@single_char_first_filter - lua_filter@other_lua_function2 Deploy & try","title":"Usage"},{"location":"#build","text":"","title":"Build"},{"location":"#build-dependencies","text":"librime >= 1.5.0 LuaJIT 2 / Lua 5.1 / Lua 5.2 / Lua 5.3 / Lua 5.4","title":"Build dependencies"},{"location":"#prebuilt-versions","text":"Windows 1.4.0 backport master","title":"Prebuilt versions"},{"location":"#instructions","text":"Prepare source code Move the source to the plugins directory of librime: mv librime-lua $PATH_TO_RIME_SOURCE/plugins/lua Or you can use the install-plugins.sh script to automatically fetch librime-lua: cd $PATH_TO_RIME_SOURCE bash install-plugins.sh hchunhui/librime-lua Install dependencies Install development files of Lua: # For Debian/Ubuntu: sudo apt install liblua5.3-dev # or libluajit-5.1-dev The build system will use pkg-config to search Lua. The build system also supports building Lua from source in the thirdparty directory. The thirdparty directory can be downloaded using the following commands: cd $PATH_TO_RIME_SOURCE/plugins/lua git clone https://github.com/hchunhui/librime-lua.git -b thirdparty --depth=1 thirdparty Build Follow the librime's build instructions. # On Linux, merged build make merged-plugins sudo make install For more information on RIME plugins, see here .","title":"Instructions"},{"location":"api/","text":"Module All librime-lua module should export as a table like {init=function, func=function, fini=function} Tips: in this document parameters were presented as function(parameter : type) or function(type) function() : type represented return type Pasted code is code of C++ source I don't understand You can call Functions of Component globally like Functions() Call Methods of Component like ComponentObject:method() Getters means properties can be accessed like Component.property Setters means properties can be access like Component.property = value Example example.schema.yaml engine: # binding lua_function to rime components translators: - lua_translator@lua_tran # lua_tran.func(input,Segment,env) filters: - lua_filter@lua_filt # lua_filt.func(input) processor: - lua_processor@lua_proc # lua_proc.func(KeyEvent,env) rime.lua lua_tran = require(\"aTranslator\") lua_filt = require(\"aFilter\") lua_proc = require(\"aProcessor\") aTranslator.lua local function main(input,segment,env) print(env.hello) -- helloRime end local function destory() print(\"Destroied!\") end local function prepare(env) env.hello = \"helloRime\" end return {init = prepare,func = main,fini = destory} aFilter.lua local function filter(input) local l = {} for cand in input:iter() do if (utf8.len(cand.text) == 1) then yield(cand) else table.insert(l, cand) end end for i, cand in ipairs(l) do yield(cand) end end return filter -- or -- return {init = nil,func = filter, fini = nil} aProcessor local function filter(key,env) print(key.keycode) end local function init(env) print(env.engine.schema.schema_id) end return {init = init, func = filter, fini = nil} init init(env) would be called when Initializing. env is the global variable of librime-Lua containing the librime environment, which has the following properties. env.engine type of engine and env.name_space type of string You could bind variables to env and use it in your module. -- in test.lua function ModuleInit(env) env.memory = Memory(env.engine,env.engine.schema) env.pyrdb = ReverseDb(\"build/terra_pinyin.reverse.bin\") end return {init = ModuleInit} func func would be called when rime is attempting to call the module. Which parameters would be passed depending on which rime component bind with the Lua module. If Module bind with Translator. func(input, Segment, env) Would be called by Translator::Query . tips: input is type of string If Module bind with Filter. func(Translation, env) would be called Filter::apply If Module bind with Processor. func(KeyEvent, env) would be called by Processor::ProcessKeyEvent fini When LuaTranslator, LuaFilter, LuaProcess being destoried fini would be called librime-lua built-in component DictEntry Functions DictEntry() : DictEntry Instance a empty DictEntry Getters text : string comment : string preedit : string weight : number commit_count : number custom_code : string remaining_code_length : number code : Code Setters text : string comment : string preedit : string weight : number commit_count : number custom_code : string remaining_code_length : number code : Code Code Functions Code() Create Empty Code Methods push(code : number) push code to Code print() print current code CommitEntry Methods get() : {DictEntry} Returns array of DictEntry in CommitEntry Memory Introduction A compoent that could access to Dictionary and UserDictionary Functions Memory(Engine, Schema) : Memory Returns the Instance of Memory Instance a Memory Object with given Engine and Scehma CustomMemory(Engine, schema_id=\"\", namespace=\"translator\") : Memory Returns the Instance of Memory Instance a Memory Object with given Engine (running Engine), a scheme_id , and namespace scheme_id were defined on input method schema cangjie5.schema.yaml schema: schema_id: cangjie5 # this one name: \u5009\u9821\u4e94\u4ee3 version: \"1.1.test\" namespace is used to collect yaml tag of namespace/dictionary namespace/enable_user_dict and namespace/db_class in schema. cangjie5.schema.yaml translator: dictionary: cangjie5 #this one! # enable_user_dict: true #this one # db_class: tabledb #this one enable_charset_filter: true enable_sentence: true enable_encoder: true encode_commit_history: true max_phrase_length: 5 preedit_format: - 'xform/^([a-z]*)$/$1\\t\uff08\\U$1\\E\uff09/' - \"xlit|ABCDEFGHIJKLMNOPQRSTUVWXYZ|\u65e5\u6708\u91d1\u6728\u6c34\u706b\u571f\u7af9\u6208\u5341\u5927\u4e2d\u4e00\u5f13\u4eba\u5fc3\u624b\u53e3\u5c38\u5eff\u5c71\u5973\u7530\u96e3\u535c\u7b26|\" comment_format: - \"xlit|abcdefghijklmnopqrstuvwxyz~|\u65e5\u6708\u91d1\u6728\u6c34\u706b\u571f\u7af9\u6208\u5341\u5927\u4e2d\u4e00\u5f13\u4eba\u5fc3\u624b\u53e3\u5c38\u5eff\u5c71\u5973\u7530\u96e3\u535c\u7b26\uff5e|\" disable_user_dict_for_patterns: - \"^z.*$\" - \"^yyy.*$\" Methods dictLookup(input : string, isExpand : boolean) : boolean Returns true if Lookup success. The results are stored in DicionaryIterator inside Memory . If isExpand were true, it would expand your input as a prefix. For example, the input is \"hq\", all results with the prefix \"hq\" in code would be output. userLookup(input : string, isExpand : boolean) : boolean Returns true if Lookup success. The results are stored in UserDicionaryIterator inside Memory . If isExpand were true, it would expand your input as a prefix. For example, the input is \"hq\", all results with the prefix \"hq\" in code would be output. iter_dict() Returns a Lua Iterator Of Dictionary Lookup Results which iterates a dictEntry. for entry in mem:iter_dict() do print(entry.text) end iter_user() Returns a Lua Iterator Of UserDictionary Lookup Results which iterates a dictEntry. for entry in mem:iter_user() do print(entry.text) end memorize(function(CommitEntry)) To bind a lua_Function to Memory::memorize The Function would be called after commit, passing CommitEntry (contains committed dictEntry ) to it. You could use CommitEntry to manage User_Dict updateUserdict(DictEntry, commits : number, new_entry_prefix : string) Update UserDictionary with specific DictEntry If commits < 0 this entry would be marked as deleted. If commits > 0 then increasing the frequency of this entry committed. new_entry_prefix would become the code prefix of this entry Segment Functions Segment(start_pos : number, end_pos : number) : Segment Returns Instance of Segment Methods clear() clean tags, reset menu,set Selected_index to 0,Clear prompt close() auto select Candidate then split into selected segment and unselcted segment reopen(caret_pos : number) bool Segment::Reopen(size_t caret_pos) { if (status < kSelected) { return false; } const size_t original_end_pos = start + length; if (original_end_pos == caret_pos) { // reuse previous candidates and keep selection if (end < original_end_pos) { // restore partial-selected segment end = original_end_pos; tags.erase(kPartialSelectionTag); } status = kGuess; } else { status = kVoid; } return true; } has_tag(tag : string) : boolean Returns if the tag has been found. get_candidate_at(index : number) : number Returns Candidate of specific index. get_selected_candidate() : Candidate Returns Candidte of selected candidte. Getters status : string Returns \"kVoid\" \"kVGuess\" \"kselected\" or \"kConfirmed\" start : number _end : number length : number Returns Segment's length tags : table Returns a set of tags menu : Menu selected_index : number prompt : string Setters status : string start : number _end : number length : number tags : table menu : Menu selected_index : number prompt : string Candidate Functions Candidate(type : string, start : number, end: number, text : string, comment : string) : Candidate Returns Instance of Candidate Methods get_dynamic_type() : string string dynamic_type(T &c) { if (dynamic_cast<Phrase *>(&c)) return \"Phrase\"; if (dynamic_cast<SimpleCandidate *>(&c)) return \"Simple\"; if (dynamic_cast<ShadowCandidate *>(&c)) return \"Shadow\"; if (dynamic_cast<UniquifiedCandidate *>(&c)) return \"Uniquified\"; return \"Other\"; } get_genuine(Candidate) : Candidate an<Candidate> Candidate::GetGenuineCandidate(const an<Candidate>& cand) { auto uniquified = As<UniquifiedCandidate>(cand); return UnpackShadowCandidate(uniquified ? uniquified->items().front() : cand); } get_genuines(Candidate) : Candidate vector<of<Candidate>> Candidate::GetGenuineCandidates(const an<Candidate>& cand) { vector<of<Candidate>> result; if (auto uniquified = As<UniquifiedCandidate>(cand)) { for (const auto& item : uniquified->items()) { result.push_back(UnpackShadowCandidate(item)); } } else { result.push_back(UnpackShadowCandidate(cand)); } return result; } Getters type : string start : number _end : number quality : number text : string comment : string preedit : string Setters type : string start : number _end : number quality : number text : string comment : string preedit : string Translation Functions Translation(initFunction : function) Returns Instance of Translation ,and call the initFunction. Methods iter() Returns lua iterator for Translation that iterate Candidate for can in translation:iter() do print(can.text) end ReverseDb Functions ReverseDb(ReverseDb_File_Name : string) : ReverseDb Returns Instance of ReverseDb Methods lookup(key : string) : string Returns string of reverseDb lookup result Segmentation Methods empty() : boolean back() : Segment Returns last element of Segmentation pop_back() Delete the last element of Segmentation reset_length(length : number) Reset Segmentation with given length add_segment(Segment) Add given Segment at Segmentation 's end forward() // finalize a round bool Segmentation::Forward() { if (empty() || back().start == back().end) return false; // initialize an empty segment for the next round push_back(Segment(back().end, back().end)); return true; } trim() // remove empty trailing segment bool Segmentation::Trim() { if (!empty() && back().start == back().end) { pop_back(); return true; } return false; } has_finished_segmentation() bool Segmentation::HasFinishedSegmentation() const { return (empty() ? 0 : back().end) >= input_.length(); } get_current_start_position() : number size_t Segmentation::GetCurrentStartPosition() const { return empty() ? 0 : back().start; } get_current_end_position() : number size_t Segmentation::GetCurrentEndPosition() const { return empty() ? 0 : back().end; } get_current_segment_length : number size_t Segmentation::GetCurrentSegmentLength() const { return empty() ? 0 : (back().end - back().start); } get_confirmed_position : number size_t Segmentation::GetConfirmedPosition() const { size_t k = 0; for (const Segment& seg : *this) { if (seg.status >= Segment::kSelected) k = seg.end; } return k; } Getters input : string Setters input : string Menu Functions add_translation(Translation) prepare(requested : number) : number size_t Menu::Prepare(size_t requested) { DLOG(INFO) << \"preparing \" << requested << \" candidates.\"; while (candidates_.size() < requested && !result_->exhausted()) { if (auto cand = result_->Peek()) { candidates_.push_back(cand); } result_->Next(); } return candidates_.size(); } get_candidate_at(index : number) : Candidate candidate_count() : number empty() : boolean KeyEvent Methods shift : boolean ctrl : boolean alt : boolean caps : boolean super : boolean release : boolean repr : string eq \uff1a boolean Returns is euqual to other KeyEvent lt : boolean Returns is less than other KeyEvent Getters keycode : number modifier : number Engine Methods commit_text(text : string) commit given text Getters schema : Schema returns current Schema context : Context returns current Context active_engine : Engine Setters active_engine(Engine) Context Methods commit() : boolean get_commit_text() : string get_script_text() : string get_preedit() : string is_composing() : boolean has_menu() : boolean get_selected_candidate() : Candidate push_input(input : string) : boolean pop_input(len : number) : boolean delete input of given amount bool Context::PopInput(size_t len) { if (caret_pos_ < len) return false; caret_pos_ -= len; // differ to DeleteInput input_.erase(caret_pos_, len); update_notifier_(this); return true; } delete_input(len : number) : boolean delete input of given amount bool Context::DeleteInput(size_t len) { if (caret_pos_ + len > input_.length()) return false; input_.erase(caret_pos_, len); update_notifier_(this); return true; } clear() select(index : number) : boolean confirm_current_selection() : boolean delete_current_selection() : boolean confirm_previous_selection() : boolean reopen_previous_selection() : boolean clear_previous_segment() : boolean reopen_previous_segment() : boolean clear_non_confirmed_composition() : boolean refresh_non_confirmed_composition() : boolean set_option(name : string, value : boolean) get_option(name : string) set_property(name : string,value : string) get_property(name : string) : string clear_transient_options() void Context::ClearTransientOptions() { auto opt = options_.lower_bound(\"_\"); while (opt != options_.end() && !opt->first.empty() && opt->first[0] == '_') { options_.erase(opt++); } auto prop = properties_.lower_bound(\"_\"); while (prop != properties_.end() && !prop->first.empty() && prop->first[0] == '_') { properties_.erase(prop++); } } Getters composition : Composition input : string caret_pos : number commit_notifier : Notifier select_notifier : Notifier update_notifier : Notifier delete_notifier : Notifier option_update_notifier : Notifier property_update_notifier : Notifier unhandled_key_notifier : Notifier Setters composition : Composition input : string caret_pos : number Preedit Getters text : string caret_pos : number sel_start : number sel_end : number Setters text : string caret_pos : number sel_start : number sel_end : number Composition Extends Segmentation Methods empty() : boolean back() : Composition pop_back() : bool push_back(Segmentation) has_finished_composition() : bool get_prompt() : string Schema Functions Schema(schema_id : string) : Schema Getters schema_id : string schema_name : string config : Config page_size : number select_keys : string Setters config : Config select_keys : string Config Methods load_from_file(file_name : string) : boolean save_to_file(file_name : string) : boolean is_null(path : string) : boolean is_value(path : string) : boolean is_list(path : string) : boolean is_map(path : string) : boolean get_bool(path : string) : boolean get_int(path : string) : number get_double(path : string) : number get_string(path : string) : string get_list_size(path : string) : number set_bool(path : string, value : bool) : bool set_int(path : string, value : number) : boolean set_double(path : string, value : number) : boolean set_string(path : string, value : string) : boolean Connection Methods disconnect() Notifier Methods connect(Notifier, Context) : Connection OptionUpdateNotifier Methods connect(OptionUpdateNotifier, string): Connection PropertyUpdateNotifier Methods connect(PropertyUpdateNotifier, string): Connection KeyEventNotifer Methods connect(KeyEventNotifer, KeyEvent) : Connection Log Use Log to logging your lua function. Functions info(string) warning(string) error(string)","title":"API"},{"location":"api/#module","text":"All librime-lua module should export as a table like {init=function, func=function, fini=function} Tips: in this document parameters were presented as function(parameter : type) or function(type) function() : type represented return type Pasted code is code of C++ source I don't understand You can call Functions of Component globally like Functions() Call Methods of Component like ComponentObject:method() Getters means properties can be accessed like Component.property Setters means properties can be access like Component.property = value","title":"Module"},{"location":"api/#example","text":"example.schema.yaml engine: # binding lua_function to rime components translators: - lua_translator@lua_tran # lua_tran.func(input,Segment,env) filters: - lua_filter@lua_filt # lua_filt.func(input) processor: - lua_processor@lua_proc # lua_proc.func(KeyEvent,env) rime.lua lua_tran = require(\"aTranslator\") lua_filt = require(\"aFilter\") lua_proc = require(\"aProcessor\") aTranslator.lua local function main(input,segment,env) print(env.hello) -- helloRime end local function destory() print(\"Destroied!\") end local function prepare(env) env.hello = \"helloRime\" end return {init = prepare,func = main,fini = destory} aFilter.lua local function filter(input) local l = {} for cand in input:iter() do if (utf8.len(cand.text) == 1) then yield(cand) else table.insert(l, cand) end end for i, cand in ipairs(l) do yield(cand) end end return filter -- or -- return {init = nil,func = filter, fini = nil} aProcessor local function filter(key,env) print(key.keycode) end local function init(env) print(env.engine.schema.schema_id) end return {init = init, func = filter, fini = nil}","title":"Example"},{"location":"api/#init","text":"init(env) would be called when Initializing. env is the global variable of librime-Lua containing the librime environment, which has the following properties. env.engine type of engine and env.name_space type of string You could bind variables to env and use it in your module. -- in test.lua function ModuleInit(env) env.memory = Memory(env.engine,env.engine.schema) env.pyrdb = ReverseDb(\"build/terra_pinyin.reverse.bin\") end return {init = ModuleInit}","title":"init"},{"location":"api/#func","text":"func would be called when rime is attempting to call the module. Which parameters would be passed depending on which rime component bind with the Lua module. If Module bind with Translator. func(input, Segment, env) Would be called by Translator::Query . tips: input is type of string If Module bind with Filter. func(Translation, env) would be called Filter::apply If Module bind with Processor. func(KeyEvent, env) would be called by Processor::ProcessKeyEvent","title":"func"},{"location":"api/#fini","text":"When LuaTranslator, LuaFilter, LuaProcess being destoried fini would be called","title":"fini"},{"location":"api/#librime-lua-built-in-component","text":"","title":"librime-lua built-in component"},{"location":"api/#dictentry","text":"","title":"DictEntry"},{"location":"api/#functions","text":"","title":"Functions"},{"location":"api/#dictentry-dictentry","text":"Instance a empty DictEntry","title":"DictEntry() : DictEntry"},{"location":"api/#getters","text":"","title":"Getters"},{"location":"api/#text-string","text":"","title":"text : string"},{"location":"api/#comment-string","text":"","title":"comment : string"},{"location":"api/#preedit-string","text":"","title":"preedit : string"},{"location":"api/#weight-number","text":"","title":"weight : number"},{"location":"api/#commit_count-number","text":"","title":"commit_count : number"},{"location":"api/#custom_code-string","text":"","title":"custom_code : string"},{"location":"api/#remaining_code_length-number","text":"","title":"remaining_code_length : number"},{"location":"api/#code-code","text":"","title":"code : Code"},{"location":"api/#setters","text":"","title":"Setters"},{"location":"api/#text-string_1","text":"","title":"text : string"},{"location":"api/#comment-string_1","text":"","title":"comment : string"},{"location":"api/#preedit-string_1","text":"","title":"preedit : string"},{"location":"api/#weight-number_1","text":"","title":"weight : number"},{"location":"api/#commit_count-number_1","text":"","title":"commit_count : number"},{"location":"api/#custom_code-string_1","text":"","title":"custom_code : string"},{"location":"api/#remaining_code_length-number_1","text":"","title":"remaining_code_length : number"},{"location":"api/#code-code_1","text":"","title":"code : Code"},{"location":"api/#code","text":"","title":"Code"},{"location":"api/#functions_1","text":"","title":"Functions"},{"location":"api/#code_1","text":"Create Empty Code","title":"Code()"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#pushcode-number","text":"push code to Code","title":"push(code : number)"},{"location":"api/#print","text":"print current code","title":"print()"},{"location":"api/#commitentry","text":"","title":"CommitEntry"},{"location":"api/#methods_1","text":"","title":"Methods"},{"location":"api/#get-dictentry","text":"Returns array of DictEntry in CommitEntry","title":"get() : {DictEntry}"},{"location":"api/#memory","text":"","title":"Memory"},{"location":"api/#introduction","text":"A compoent that could access to Dictionary and UserDictionary","title":"Introduction"},{"location":"api/#functions_2","text":"","title":"Functions"},{"location":"api/#memoryengine-schema-memory","text":"Returns the Instance of Memory Instance a Memory Object with given Engine and Scehma","title":"Memory(Engine, Schema) : Memory"},{"location":"api/#custommemoryengine-schema_id-namespacetranslator-memory","text":"Returns the Instance of Memory Instance a Memory Object with given Engine (running Engine), a scheme_id , and namespace scheme_id were defined on input method schema cangjie5.schema.yaml schema: schema_id: cangjie5 # this one name: \u5009\u9821\u4e94\u4ee3 version: \"1.1.test\" namespace is used to collect yaml tag of namespace/dictionary namespace/enable_user_dict and namespace/db_class in schema. cangjie5.schema.yaml translator: dictionary: cangjie5 #this one! # enable_user_dict: true #this one # db_class: tabledb #this one enable_charset_filter: true enable_sentence: true enable_encoder: true encode_commit_history: true max_phrase_length: 5 preedit_format: - 'xform/^([a-z]*)$/$1\\t\uff08\\U$1\\E\uff09/' - \"xlit|ABCDEFGHIJKLMNOPQRSTUVWXYZ|\u65e5\u6708\u91d1\u6728\u6c34\u706b\u571f\u7af9\u6208\u5341\u5927\u4e2d\u4e00\u5f13\u4eba\u5fc3\u624b\u53e3\u5c38\u5eff\u5c71\u5973\u7530\u96e3\u535c\u7b26|\" comment_format: - \"xlit|abcdefghijklmnopqrstuvwxyz~|\u65e5\u6708\u91d1\u6728\u6c34\u706b\u571f\u7af9\u6208\u5341\u5927\u4e2d\u4e00\u5f13\u4eba\u5fc3\u624b\u53e3\u5c38\u5eff\u5c71\u5973\u7530\u96e3\u535c\u7b26\uff5e|\" disable_user_dict_for_patterns: - \"^z.*$\" - \"^yyy.*$\"","title":"CustomMemory(Engine, schema_id=\"\", namespace=\"translator\") : Memory"},{"location":"api/#methods_2","text":"","title":"Methods"},{"location":"api/#dictlookupinput-string-isexpand-boolean-boolean","text":"Returns true if Lookup success. The results are stored in DicionaryIterator inside Memory . If isExpand were true, it would expand your input as a prefix. For example, the input is \"hq\", all results with the prefix \"hq\" in code would be output.","title":"dictLookup(input : string, isExpand : boolean) : boolean"},{"location":"api/#userlookupinput-string-isexpand-boolean-boolean","text":"Returns true if Lookup success. The results are stored in UserDicionaryIterator inside Memory . If isExpand were true, it would expand your input as a prefix. For example, the input is \"hq\", all results with the prefix \"hq\" in code would be output.","title":"userLookup(input : string, isExpand : boolean) : boolean"},{"location":"api/#iter_dict","text":"Returns a Lua Iterator Of Dictionary Lookup Results which iterates a dictEntry. for entry in mem:iter_dict() do print(entry.text) end","title":"iter_dict()"},{"location":"api/#iter_user","text":"Returns a Lua Iterator Of UserDictionary Lookup Results which iterates a dictEntry. for entry in mem:iter_user() do print(entry.text) end","title":"iter_user()"},{"location":"api/#memorizefunctioncommitentry","text":"To bind a lua_Function to Memory::memorize The Function would be called after commit, passing CommitEntry (contains committed dictEntry ) to it. You could use CommitEntry to manage User_Dict","title":"memorize(function(CommitEntry))"},{"location":"api/#updateuserdictdictentry-commits-number-new_entry_prefix-string","text":"Update UserDictionary with specific DictEntry If commits < 0 this entry would be marked as deleted. If commits > 0 then increasing the frequency of this entry committed. new_entry_prefix would become the code prefix of this entry","title":"updateUserdict(DictEntry, commits : number, new_entry_prefix : string)"},{"location":"api/#segment","text":"","title":"Segment"},{"location":"api/#functions_3","text":"","title":"Functions"},{"location":"api/#segmentstart_pos-number-end_pos-number-segment","text":"Returns Instance of Segment","title":"Segment(start_pos : number, end_pos : number) : Segment"},{"location":"api/#methods_3","text":"","title":"Methods"},{"location":"api/#clear","text":"clean tags, reset menu,set Selected_index to 0,Clear prompt","title":"clear()"},{"location":"api/#close","text":"auto select Candidate then split into selected segment and unselcted segment","title":"close()"},{"location":"api/#reopencaret_pos-number","text":"bool Segment::Reopen(size_t caret_pos) { if (status < kSelected) { return false; } const size_t original_end_pos = start + length; if (original_end_pos == caret_pos) { // reuse previous candidates and keep selection if (end < original_end_pos) { // restore partial-selected segment end = original_end_pos; tags.erase(kPartialSelectionTag); } status = kGuess; } else { status = kVoid; } return true; }","title":"reopen(caret_pos : number)"},{"location":"api/#has_tagtag-string-boolean","text":"Returns if the tag has been found.","title":"has_tag(tag : string) : boolean"},{"location":"api/#get_candidate_atindex-number-number","text":"Returns Candidate of specific index.","title":"get_candidate_at(index : number) : number"},{"location":"api/#get_selected_candidate-candidate","text":"Returns Candidte of selected candidte.","title":"get_selected_candidate() : Candidate"},{"location":"api/#getters_1","text":"","title":"Getters"},{"location":"api/#status-string","text":"Returns \"kVoid\" \"kVGuess\" \"kselected\" or \"kConfirmed\"","title":"status : string"},{"location":"api/#start-number","text":"","title":"start : number"},{"location":"api/#_end-number","text":"","title":"_end : number"},{"location":"api/#length-number","text":"Returns Segment's length","title":"length : number"},{"location":"api/#tags-table","text":"Returns a set of tags","title":"tags : table"},{"location":"api/#menu-menu","text":"","title":"menu : Menu"},{"location":"api/#selected_index-number","text":"","title":"selected_index : number"},{"location":"api/#prompt-string","text":"","title":"prompt : string"},{"location":"api/#setters_1","text":"","title":"Setters"},{"location":"api/#status-string_1","text":"","title":"status : string"},{"location":"api/#start-number_1","text":"","title":"start : number"},{"location":"api/#_end-number_1","text":"","title":"_end : number"},{"location":"api/#length-number_1","text":"","title":"length : number"},{"location":"api/#tags-table_1","text":"","title":"tags : table"},{"location":"api/#menu-menu_1","text":"","title":"menu : Menu"},{"location":"api/#selected_index-number_1","text":"","title":"selected_index : number"},{"location":"api/#prompt-string_1","text":"","title":"prompt : string"},{"location":"api/#candidate","text":"","title":"Candidate"},{"location":"api/#functions_4","text":"","title":"Functions"},{"location":"api/#candidatetype-string-start-number-end-number-text-string-comment-string-candidate","text":"Returns Instance of Candidate","title":"Candidate(type : string, start : number, end: number, text : string, comment : string) : Candidate"},{"location":"api/#methods_4","text":"","title":"Methods"},{"location":"api/#get_dynamic_type-string","text":"string dynamic_type(T &c) { if (dynamic_cast<Phrase *>(&c)) return \"Phrase\"; if (dynamic_cast<SimpleCandidate *>(&c)) return \"Simple\"; if (dynamic_cast<ShadowCandidate *>(&c)) return \"Shadow\"; if (dynamic_cast<UniquifiedCandidate *>(&c)) return \"Uniquified\"; return \"Other\"; }","title":"get_dynamic_type() : string"},{"location":"api/#get_genuinecandidate-candidate","text":"an<Candidate> Candidate::GetGenuineCandidate(const an<Candidate>& cand) { auto uniquified = As<UniquifiedCandidate>(cand); return UnpackShadowCandidate(uniquified ? uniquified->items().front() : cand); }","title":"get_genuine(Candidate) : Candidate"},{"location":"api/#get_genuinescandidate-candidate","text":"vector<of<Candidate>> Candidate::GetGenuineCandidates(const an<Candidate>& cand) { vector<of<Candidate>> result; if (auto uniquified = As<UniquifiedCandidate>(cand)) { for (const auto& item : uniquified->items()) { result.push_back(UnpackShadowCandidate(item)); } } else { result.push_back(UnpackShadowCandidate(cand)); } return result; }","title":"get_genuines(Candidate) : Candidate"},{"location":"api/#getters_2","text":"","title":"Getters"},{"location":"api/#type-string","text":"","title":"type : string"},{"location":"api/#start-number_2","text":"","title":"start : number"},{"location":"api/#_end-number_2","text":"","title":"_end : number"},{"location":"api/#quality-number","text":"","title":"quality : number"},{"location":"api/#text-string_2","text":"","title":"text : string"},{"location":"api/#comment-string_2","text":"","title":"comment : string"},{"location":"api/#preedit-string_2","text":"","title":"preedit : string"},{"location":"api/#setters_2","text":"","title":"Setters"},{"location":"api/#type-string_1","text":"","title":"type : string"},{"location":"api/#start-number_3","text":"","title":"start : number"},{"location":"api/#_end-number_3","text":"","title":"_end : number"},{"location":"api/#quality-number_1","text":"","title":"quality : number"},{"location":"api/#text-string_3","text":"","title":"text : string"},{"location":"api/#comment-string_3","text":"","title":"comment : string"},{"location":"api/#preedit-string_3","text":"","title":"preedit : string"},{"location":"api/#translation","text":"","title":"Translation"},{"location":"api/#functions_5","text":"","title":"Functions"},{"location":"api/#translationinitfunction-function","text":"Returns Instance of Translation ,and call the initFunction.","title":"Translation(initFunction : function)"},{"location":"api/#methods_5","text":"","title":"Methods"},{"location":"api/#iter","text":"Returns lua iterator for Translation that iterate Candidate for can in translation:iter() do print(can.text) end","title":"iter()"},{"location":"api/#reversedb","text":"","title":"ReverseDb"},{"location":"api/#functions_6","text":"","title":"Functions"},{"location":"api/#reversedbreversedb_file_name-string-reversedb","text":"Returns Instance of ReverseDb","title":"ReverseDb(ReverseDb_File_Name : string) : ReverseDb"},{"location":"api/#methods_6","text":"","title":"Methods"},{"location":"api/#lookupkey-string-string","text":"Returns string of reverseDb lookup result","title":"lookup(key : string) : string"},{"location":"api/#segmentation","text":"","title":"Segmentation"},{"location":"api/#methods_7","text":"","title":"Methods"},{"location":"api/#empty-boolean","text":"","title":"empty() : boolean"},{"location":"api/#back-segment","text":"Returns last element of Segmentation","title":"back() : Segment"},{"location":"api/#pop_back","text":"Delete the last element of Segmentation","title":"pop_back()"},{"location":"api/#reset_lengthlength-number","text":"Reset Segmentation with given length","title":"reset_length(length : number)"},{"location":"api/#add_segmentsegment","text":"Add given Segment at Segmentation 's end","title":"add_segment(Segment)"},{"location":"api/#forward","text":"// finalize a round bool Segmentation::Forward() { if (empty() || back().start == back().end) return false; // initialize an empty segment for the next round push_back(Segment(back().end, back().end)); return true; }","title":"forward()"},{"location":"api/#trim","text":"// remove empty trailing segment bool Segmentation::Trim() { if (!empty() && back().start == back().end) { pop_back(); return true; } return false; }","title":"trim()"},{"location":"api/#has_finished_segmentation","text":"bool Segmentation::HasFinishedSegmentation() const { return (empty() ? 0 : back().end) >= input_.length(); }","title":"has_finished_segmentation()"},{"location":"api/#get_current_start_position-number","text":"size_t Segmentation::GetCurrentStartPosition() const { return empty() ? 0 : back().start; }","title":"get_current_start_position() : number"},{"location":"api/#get_current_end_position-number","text":"size_t Segmentation::GetCurrentEndPosition() const { return empty() ? 0 : back().end; }","title":"get_current_end_position() : number"},{"location":"api/#get_current_segment_length-number","text":"size_t Segmentation::GetCurrentSegmentLength() const { return empty() ? 0 : (back().end - back().start); }","title":"get_current_segment_length : number"},{"location":"api/#get_confirmed_position-number","text":"size_t Segmentation::GetConfirmedPosition() const { size_t k = 0; for (const Segment& seg : *this) { if (seg.status >= Segment::kSelected) k = seg.end; } return k; }","title":"get_confirmed_position : number"},{"location":"api/#getters_3","text":"","title":"Getters"},{"location":"api/#input-string","text":"","title":"input : string"},{"location":"api/#setters_3","text":"","title":"Setters"},{"location":"api/#input-string_1","text":"","title":"input : string"},{"location":"api/#menu","text":"","title":"Menu"},{"location":"api/#functions_7","text":"","title":"Functions"},{"location":"api/#add_translationtranslation","text":"","title":"add_translation(Translation)"},{"location":"api/#preparerequested-number-number","text":"size_t Menu::Prepare(size_t requested) { DLOG(INFO) << \"preparing \" << requested << \" candidates.\"; while (candidates_.size() < requested && !result_->exhausted()) { if (auto cand = result_->Peek()) { candidates_.push_back(cand); } result_->Next(); } return candidates_.size(); }","title":"prepare(requested : number) : number"},{"location":"api/#get_candidate_atindex-number-candidate","text":"","title":"get_candidate_at(index : number) : Candidate"},{"location":"api/#candidate_count-number","text":"","title":"candidate_count() : number"},{"location":"api/#empty-boolean_1","text":"","title":"empty() : boolean"},{"location":"api/#keyevent","text":"","title":"KeyEvent"},{"location":"api/#methods_8","text":"","title":"Methods"},{"location":"api/#shift-boolean","text":"","title":"shift : boolean"},{"location":"api/#ctrl-boolean","text":"","title":"ctrl : boolean"},{"location":"api/#alt-boolean","text":"","title":"alt : boolean"},{"location":"api/#caps-boolean","text":"","title":"caps : boolean"},{"location":"api/#super-boolean","text":"","title":"super : boolean"},{"location":"api/#release-boolean","text":"","title":"release : boolean"},{"location":"api/#repr-string","text":"","title":"repr : string"},{"location":"api/#eq-boolean","text":"Returns is euqual to other KeyEvent","title":"eq \uff1a boolean"},{"location":"api/#lt-boolean","text":"Returns is less than other KeyEvent","title":"lt : boolean"},{"location":"api/#getters_4","text":"","title":"Getters"},{"location":"api/#keycode-number","text":"","title":"keycode : number"},{"location":"api/#modifier-number","text":"","title":"modifier : number"},{"location":"api/#engine","text":"","title":"Engine"},{"location":"api/#methods_9","text":"","title":"Methods"},{"location":"api/#commit_texttext-string","text":"commit given text","title":"commit_text(text : string)"},{"location":"api/#getters_5","text":"","title":"Getters"},{"location":"api/#schema-schema","text":"returns current Schema","title":"schema : Schema"},{"location":"api/#context-context","text":"returns current Context","title":"context : Context"},{"location":"api/#active_engine-engine","text":"","title":"active_engine : Engine"},{"location":"api/#setters_4","text":"","title":"Setters"},{"location":"api/#active_engineengine","text":"","title":"active_engine(Engine)"},{"location":"api/#context","text":"","title":"Context"},{"location":"api/#methods_10","text":"","title":"Methods"},{"location":"api/#commit-boolean","text":"","title":"commit() : boolean"},{"location":"api/#get_commit_text-string","text":"","title":"get_commit_text() : string"},{"location":"api/#get_script_text-string","text":"","title":"get_script_text() : string"},{"location":"api/#get_preedit-string","text":"","title":"get_preedit() : string"},{"location":"api/#is_composing-boolean","text":"","title":"is_composing() : boolean"},{"location":"api/#has_menu-boolean","text":"","title":"has_menu() : boolean"},{"location":"api/#get_selected_candidate-candidate_1","text":"","title":"get_selected_candidate() : Candidate"},{"location":"api/#push_inputinput-string-boolean","text":"","title":"push_input(input : string) : boolean"},{"location":"api/#pop_inputlen-number-boolean","text":"delete input of given amount bool Context::PopInput(size_t len) { if (caret_pos_ < len) return false; caret_pos_ -= len; // differ to DeleteInput input_.erase(caret_pos_, len); update_notifier_(this); return true; }","title":"pop_input(len : number) : boolean"},{"location":"api/#delete_inputlen-number-boolean","text":"delete input of given amount bool Context::DeleteInput(size_t len) { if (caret_pos_ + len > input_.length()) return false; input_.erase(caret_pos_, len); update_notifier_(this); return true; }","title":"delete_input(len : number) : boolean"},{"location":"api/#clear_1","text":"","title":"clear()"},{"location":"api/#selectindex-number-boolean","text":"","title":"select(index : number) : boolean"},{"location":"api/#confirm_current_selection-boolean","text":"","title":"confirm_current_selection() : boolean"},{"location":"api/#delete_current_selection-boolean","text":"","title":"delete_current_selection() : boolean"},{"location":"api/#confirm_previous_selection-boolean","text":"","title":"confirm_previous_selection() : boolean"},{"location":"api/#reopen_previous_selection-boolean","text":"","title":"reopen_previous_selection() : boolean"},{"location":"api/#clear_previous_segment-boolean","text":"","title":"clear_previous_segment() : boolean"},{"location":"api/#reopen_previous_segment-boolean","text":"","title":"reopen_previous_segment() : boolean"},{"location":"api/#clear_non_confirmed_composition-boolean","text":"","title":"clear_non_confirmed_composition() : boolean"},{"location":"api/#refresh_non_confirmed_composition-boolean","text":"","title":"refresh_non_confirmed_composition() : boolean"},{"location":"api/#set_optionname-string-value-boolean","text":"","title":"set_option(name : string, value : boolean)"},{"location":"api/#get_optionname-string","text":"","title":"get_option(name : string)"},{"location":"api/#set_propertyname-stringvalue-string","text":"","title":"set_property(name : string,value : string)"},{"location":"api/#get_propertyname-string-string","text":"","title":"get_property(name : string) : string"},{"location":"api/#clear_transient_options","text":"void Context::ClearTransientOptions() { auto opt = options_.lower_bound(\"_\"); while (opt != options_.end() && !opt->first.empty() && opt->first[0] == '_') { options_.erase(opt++); } auto prop = properties_.lower_bound(\"_\"); while (prop != properties_.end() && !prop->first.empty() && prop->first[0] == '_') { properties_.erase(prop++); } }","title":"clear_transient_options()"},{"location":"api/#getters_6","text":"","title":"Getters"},{"location":"api/#composition-composition","text":"","title":"composition : Composition"},{"location":"api/#input-string_2","text":"","title":"input : string"},{"location":"api/#caret_pos-number","text":"","title":"caret_pos : number"},{"location":"api/#commit_notifier-notifier","text":"","title":"commit_notifier : Notifier"},{"location":"api/#select_notifier-notifier","text":"","title":"select_notifier : Notifier"},{"location":"api/#update_notifier-notifier","text":"","title":"update_notifier : Notifier"},{"location":"api/#delete_notifier-notifier","text":"","title":"delete_notifier : Notifier"},{"location":"api/#option_update_notifier-notifier","text":"","title":"option_update_notifier : Notifier"},{"location":"api/#property_update_notifier-notifier","text":"","title":"property_update_notifier : Notifier"},{"location":"api/#unhandled_key_notifier-notifier","text":"","title":"unhandled_key_notifier : Notifier"},{"location":"api/#setters_5","text":"","title":"Setters"},{"location":"api/#composition-composition_1","text":"","title":"composition : Composition"},{"location":"api/#input-string_3","text":"","title":"input : string"},{"location":"api/#caret_pos-number_1","text":"","title":"caret_pos : number"},{"location":"api/#preedit","text":"","title":"Preedit"},{"location":"api/#getters_7","text":"","title":"Getters"},{"location":"api/#text-string_4","text":"","title":"text : string"},{"location":"api/#caret_pos-number_2","text":"","title":"caret_pos : number"},{"location":"api/#sel_start-number","text":"","title":"sel_start : number"},{"location":"api/#sel_end-number","text":"","title":"sel_end : number"},{"location":"api/#setters_6","text":"","title":"Setters"},{"location":"api/#text-string_5","text":"","title":"text : string"},{"location":"api/#caret_pos-number_3","text":"","title":"caret_pos : number"},{"location":"api/#sel_start-number_1","text":"","title":"sel_start : number"},{"location":"api/#sel_end-number_1","text":"","title":"sel_end : number"},{"location":"api/#composition","text":"Extends Segmentation","title":"Composition"},{"location":"api/#methods_11","text":"","title":"Methods"},{"location":"api/#empty-boolean_2","text":"","title":"empty() : boolean"},{"location":"api/#back-composition","text":"","title":"back() : Composition"},{"location":"api/#pop_back-bool","text":"","title":"pop_back() : bool"},{"location":"api/#push_backsegmentation","text":"","title":"push_back(Segmentation)"},{"location":"api/#has_finished_composition-bool","text":"","title":"has_finished_composition() : bool"},{"location":"api/#get_prompt-string","text":"","title":"get_prompt() : string"},{"location":"api/#schema","text":"","title":"Schema"},{"location":"api/#functions_8","text":"","title":"Functions"},{"location":"api/#schemaschema_id-string-schema","text":"","title":"Schema(schema_id : string) : Schema"},{"location":"api/#getters_8","text":"","title":"Getters"},{"location":"api/#schema_id-string","text":"","title":"schema_id : string"},{"location":"api/#schema_name-string","text":"","title":"schema_name : string"},{"location":"api/#config-config","text":"","title":"config : Config"},{"location":"api/#page_size-number","text":"","title":"page_size : number"},{"location":"api/#select_keys-string","text":"","title":"select_keys : string"},{"location":"api/#setters_7","text":"","title":"Setters"},{"location":"api/#config-config_1","text":"","title":"config : Config"},{"location":"api/#select_keys-string_1","text":"","title":"select_keys : string"},{"location":"api/#config","text":"","title":"Config"},{"location":"api/#methods_12","text":"","title":"Methods"},{"location":"api/#load_from_filefile_name-string-boolean","text":"","title":"load_from_file(file_name : string) : boolean"},{"location":"api/#save_to_filefile_name-string-boolean","text":"","title":"save_to_file(file_name : string) : boolean"},{"location":"api/#is_nullpath-string-boolean","text":"","title":"is_null(path : string) : boolean"},{"location":"api/#is_valuepath-string-boolean","text":"","title":"is_value(path : string) : boolean"},{"location":"api/#is_listpath-string-boolean","text":"","title":"is_list(path : string) : boolean"},{"location":"api/#is_mappath-string-boolean","text":"","title":"is_map(path : string) : boolean"},{"location":"api/#get_boolpath-string-boolean","text":"","title":"get_bool(path : string) : boolean"},{"location":"api/#get_intpath-string-number","text":"","title":"get_int(path : string) : number"},{"location":"api/#get_doublepath-string-number","text":"","title":"get_double(path : string) : number"},{"location":"api/#get_stringpath-string-string","text":"","title":"get_string(path : string) : string"},{"location":"api/#get_list_sizepath-string-number","text":"","title":"get_list_size(path : string) : number"},{"location":"api/#set_boolpath-string-value-bool-bool","text":"","title":"set_bool(path : string, value : bool) : bool"},{"location":"api/#set_intpath-string-value-number-boolean","text":"","title":"set_int(path : string, value : number) : boolean"},{"location":"api/#set_doublepath-string-value-number-boolean","text":"","title":"set_double(path : string, value : number) : boolean"},{"location":"api/#set_stringpath-string-value-string-boolean","text":"","title":"set_string(path : string, value : string) : boolean"},{"location":"api/#connection","text":"","title":"Connection"},{"location":"api/#methods_13","text":"","title":"Methods"},{"location":"api/#disconnect","text":"","title":"disconnect()"},{"location":"api/#notifier","text":"","title":"Notifier"},{"location":"api/#methods_14","text":"","title":"Methods"},{"location":"api/#connectnotifier-context-connection","text":"","title":"connect(Notifier, Context) : Connection"},{"location":"api/#optionupdatenotifier","text":"","title":"OptionUpdateNotifier"},{"location":"api/#methods_15","text":"","title":"Methods"},{"location":"api/#connectoptionupdatenotifier-string-connection","text":"","title":"connect(OptionUpdateNotifier, string): Connection"},{"location":"api/#propertyupdatenotifier","text":"","title":"PropertyUpdateNotifier"},{"location":"api/#methods_16","text":"","title":"Methods"},{"location":"api/#connectpropertyupdatenotifier-string-connection","text":"","title":"connect(PropertyUpdateNotifier, string): Connection"},{"location":"api/#keyeventnotifer","text":"","title":"KeyEventNotifer"},{"location":"api/#methods_17","text":"","title":"Methods"},{"location":"api/#connectkeyeventnotifer-keyevent-connection","text":"","title":"connect(KeyEventNotifer, KeyEvent) : Connection"},{"location":"api/#log","text":"Use Log to logging your lua function.","title":"Log"},{"location":"api/#functions_9","text":"","title":"Functions"},{"location":"api/#infostring","text":"","title":"info(string)"},{"location":"api/#warningstring","text":"","title":"warning(string)"},{"location":"api/#errorstring","text":"","title":"error(string)"},{"location":"usage/","text":"Introduction Welcome to librime-lua This page would teach you how to compose a lua script for librime Export Lua function to librime Create rime.lua Please Create Rime.lua at PATH_TO_RIME_USER_DATA_DIR/rime.lua This is the only entry for librime to access lua component, All function in rime.lua would exposed to librime. Import function to rime.lua rime.lua All lua function Example are in librime-lua-src/example -- translators: -- date_translator Details at `lua/date.lua` -- Translate `date` to current date. date_translator = require(\"date\") -- time_translator Details at `lua/time.lua` -- Translate `time` to current time. time_translator = require(\"time\") -- number_translator Details at `lua/number.lua` -- translate '/' + Digits to Digits in Han Character number_translator = require(\"number\") -- Filters: -- charset_filter Details at `lua/charset.lua` -- charset_filter\uff1b filter for CJK Extended Candidate -- charset_comment_filter: Add Comment for Specified charset local charset = require(\"charset\") charset_filter = charset.filter charset_comment_filter = charset.comment_filter -- Details at `lua/single_char.lua` -- single_char_filter: Bringing Candidte with Single Character to first place by sorting Candidate single_char_filter = require(\"single_char\") -- reverse_lookup Details at `lua/reverse.lua` -- ADD PINYIN comment to terra_pinyin reverse_lookup_filter = require(\"reverse\") Bind lua Function to rime schema Write something below on Rime schema engine: translators: - lua_translator@date - lua_translator@time filters: - lua_filter@charset - lua_filter@single_char_filter Then Rime Engine would able to call lua Function. Introducing built-in librime-lua Component! Check out API page for more details!","title":"Usage"},{"location":"usage/#introduction","text":"Welcome to librime-lua This page would teach you how to compose a lua script for librime","title":"Introduction"},{"location":"usage/#export-lua-function-to-librime","text":"","title":"Export Lua function to librime"},{"location":"usage/#create-rimelua","text":"Please Create Rime.lua at PATH_TO_RIME_USER_DATA_DIR/rime.lua This is the only entry for librime to access lua component, All function in rime.lua would exposed to librime.","title":"Create rime.lua"},{"location":"usage/#import-function-to-rimelua","text":"rime.lua All lua function Example are in librime-lua-src/example -- translators: -- date_translator Details at `lua/date.lua` -- Translate `date` to current date. date_translator = require(\"date\") -- time_translator Details at `lua/time.lua` -- Translate `time` to current time. time_translator = require(\"time\") -- number_translator Details at `lua/number.lua` -- translate '/' + Digits to Digits in Han Character number_translator = require(\"number\") -- Filters: -- charset_filter Details at `lua/charset.lua` -- charset_filter\uff1b filter for CJK Extended Candidate -- charset_comment_filter: Add Comment for Specified charset local charset = require(\"charset\") charset_filter = charset.filter charset_comment_filter = charset.comment_filter -- Details at `lua/single_char.lua` -- single_char_filter: Bringing Candidte with Single Character to first place by sorting Candidate single_char_filter = require(\"single_char\") -- reverse_lookup Details at `lua/reverse.lua` -- ADD PINYIN comment to terra_pinyin reverse_lookup_filter = require(\"reverse\")","title":"Import function to rime.lua"},{"location":"usage/#bind-lua-function-to-rime-schema","text":"Write something below on Rime schema engine: translators: - lua_translator@date - lua_translator@time filters: - lua_filter@charset - lua_filter@single_char_filter Then Rime Engine would able to call lua Function.","title":"Bind lua Function to rime schema"},{"location":"usage/#introducing-built-in-librime-lua-component","text":"Check out API page for more details!","title":"Introducing built-in librime-lua Component!"}]}